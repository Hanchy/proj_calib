#include <algorithm>

#include "camera.h"
#include "read_data.hpp"
#include "SpacePoints.hpp"
#include "bundle_adjuster.hpp"

void draw_points(const Camera &_cam, cv::Mat &_plane);
void draw_r_points(const Camera &_cam, cv::Mat &_plane);
void common_points_idx(const Camera &_cam1, const Camera &_cam2,
                       std::vector<int> &_order_img);

void retrieve_points(const Camera &_cam, const std::vector<int> &_pt_idx,
                     std::vector<cv::Point2d> &_pts);

void construct_3d_pts(std::vector<Camera> &_cams,
                      SpacePoints<cv::Point3d> &_space_pts);

int main(int argc, char **argv) {
  
  if (argc != 3)
    return -1;
  std::vector<Camera> cams;
  read_cams(argv[1], argv[2], cams);
  

  cv::namedWindow("pts0", cv::WINDOW_NORMAL);
  cv::namedWindow("pts1", cv::WINDOW_NORMAL);
  cv::namedWindow("pts2", cv::WINDOW_NORMAL);

  cv::Mat img0(cams[0].rows_, cams[0].cols_, 
               CV_32FC3, cv::Scalar(255,255,255));
  draw_points(cams[0], img0);
  draw_r_points(cams[0], img0);

  cv::Mat img1(cams[0].rows_, cams[0].cols_, 
               CV_32FC3, cv::Scalar(255,255,255));
  draw_points(cams[1], img1);
  draw_r_points(cams[1], img1);
#if 0


  cv::Mat img2(cams[0].rows_, cams[0].cols_, 
               CV_32FC3, cv::Scalar(255,255,255));
  draw_points(cams[2], img2);


  std::vector<int> common_pt_idx;
  common_points_idx(cams[1], cams[2], common_pt_idx);
  std::cout << "common_pt_idx " << common_pt_idx.size() << std::endl;
  
  std::vector<cv::Point2d> common_pt1;
  retrieve_points(cams[1], common_pt_idx, common_pt1);
  std::cout << "common_pt1 " << common_pt1.size() << std::endl;
  for(auto &pt : common_pt1) {
    cv::circle(img1, pt, 13, cv::Scalar(255, 0, 0), 2);
  }

  std::vector<cv::Point2d> common_pt2;
  retrieve_points(cams[2], common_pt_idx, common_pt2);
  std::cout << "common_pt2 " << common_pt2.size() << std::endl;
  for(auto &pt : common_pt2) {
    cv::circle(img2, pt, 13, cv::Scalar(255, 0, 0), 2);
  }

  cv::Mat hcont;
  cv::hconcat(img1, img2, hcont);
  for (std::size_t i = 0; i < common_pt_idx.size(); ++i) {
    const auto &pt0 = common_pt1[i];
    auto pt1 = common_pt2[i] + cv::Point2d(cams[1].cols_, 0);
    cv::line(hcont, pt0, pt1, cv::Scalar(0, 255, 0), 2);
  }
#endif

  SpacePoints<cv::Point3d> space_points;
  construct_3d_pts(cams, space_points);

  cv::imshow("pts0", img0);
  cv::imshow("pts1", img1);
  // cv::imshow("pts2", img2);
  cv::waitKey(0);




  return 0;
}


void draw_points(const Camera &_cam, cv::Mat &_plane) {
  // _plane = cv::Mat(_cam.rows_, _cam.cols_, 
  //                  CV_32FC3, cv::Scalar(255,255,255));
  
  for(auto &pt : _cam.img_pts_) {
    cv::circle(_plane, pt, 10, cv::Scalar(0, 0, 255), 2);
  }
}

void draw_r_points(const Camera &_cam, cv::Mat &_plane) {
  // _plane = cv::Mat(_cam.rows_, _cam.cols_, 
  //                  CV_32FC3, cv::Scalar(255,255,255));
  const auto &K = _cam.intrinsic_;
  for(const auto &pt : _cam.rectified_pts_) {
    double data[3] = {pt.x, pt.y, 1};
    cv::Mat h_pt(3, 1, CV_64F, data);
    h_pt = K * h_pt;
    cv::Point2d npt(data[0]/data[2], data[1]/data[2]);
    cv::circle(_plane, npt, 5, cv::Scalar(0, 0, 0), 2);
  }
}


template<typename Tk, typename Tv>
void retrieve_keys(const std::map<Tk, Tv> &_map,
                   std::vector<Tk> &_vk) {
  _vk.clear();

  std::for_each(_map.begin(), _map.end(), 
                [&_vk](const std::pair<Tk, Tv> &p) {
                  _vk.push_back(p.first);
                });
}

void common_points_idx(const Camera &_cam1, 
                       const Camera &_cam2,
                       std::vector<int> &_common_labels) {
  const auto &map_i_p1 = _cam1.l2imgpt_idx_;
  const auto &map_i_p2 = _cam2.l2imgpt_idx_;


  std::vector<int> key1;
  retrieve_keys(map_i_p1, key1);
  std::sort(key1.begin(), key1.end());

  
  std::vector<int> key2;
  retrieve_keys(map_i_p2, key2);
  std::sort(key2.begin(), key2.end());

  std::set_intersection(key1.begin(), key1.end(),
                        key2.begin(), key2.end(),
                        std::back_inserter(_common_labels));
}



void retrieve_points(const Camera &_cam, 
                     const std::vector<int> &_pt_idx,
                     std::vector<cv::Point2d> &_pts) {
  const auto &i_p_idx = _cam.l2imgpt_idx_;
  const auto &pts_buf = _cam.img_pts_;

  for (const auto i : _pt_idx) {
    auto search = i_p_idx.find(i);
    if (search != i_p_idx.end()) {
      auto buf_idx = search->second;
      _pts.push_back(pts_buf[buf_idx]);
    }
  }
}

void rectify_pts(const cv::Mat &_invK, 
                 const std::vector<cv::Point2d> &_input_pts,
                 std::vector<cv::Point2d> &_output_pts) {
  
  std::for_each(_input_pts.begin(), _input_pts.end(), 
                [&](const cv::Point2d &pt) {
                  cv::Mat homo = cv::Mat::ones(3, 1, CV_32F);
                  homo.at<float>(0, 0) = pt.x;
                  homo.at<float>(1, 0) = pt.y;
                  cv::Mat rectified = _invK * homo;
                  auto x = rectified.at<float>(0, 0)/rectified.at<float>(2, 0);
                  auto y = rectified.at<float>(1, 0)/rectified.at<float>(2, 0);
                  _output_pts.push_back(cv::Point2d(x, y));
                });
}

void retrieve_rectified_pts(const Camera &_cam, 
                            const std::vector<int> &_idx,
                            std::vector<cv::Point2d> &_r_pts) {

  const auto &i_p_idx = _cam.l2imgpt_idx_;
  const auto &pts_buf = _cam.rectified_pts_;

  for (const auto i : _idx) {
    auto search = i_p_idx.find(i);
    if (search != i_p_idx.end()) {
      auto buf_idx = search->second;
      _r_pts.push_back(pts_buf[buf_idx]);
    }
  }
}

void triangulate_pts(Camera &_cam1,
                     Camera &_cam2,
                     SpacePoints<cv::Point3d> &_space_pts) {

  std::vector<int> common_labels;
  common_points_idx(_cam1, _cam2, common_labels);
  std::sort(common_labels.begin(), common_labels.end());
  std::cout << "common_labels size " << common_labels.size() << std::endl;

  std::vector<cv::Point2d> rectified_pts1;
  retrieve_rectified_pts(_cam1, common_labels, rectified_pts1);
  std::vector<cv::Point2d> rectified_pts2;
  retrieve_rectified_pts(_cam2, common_labels, rectified_pts2);

  cv::Mat essentialMat = 
      cv::findEssentialMat(rectified_pts1, rectified_pts2, 
                           1.0, cv::Point2d(0, 0), cv::RANSAC, 0.999, 0.1);
  

  cv::Mat R(3, 3, CV_64F);
  cv::Mat t(3, 1, CV_64F);
  cv::recoverPose(essentialMat, rectified_pts1, 
                  rectified_pts2, R, t);
  
  std::cout << "R " << std::endl;
  std::cout << R << std::endl;

  _cam2.R_ = R * _cam1.R_;
  _cam2.t_ = R * _cam1.t_ + R * _cam1.R_ * R.t() * t;

  cv::Mat projMat1(3, 4, CV_64F);
  cv::hconcat(_cam1.R_, _cam1.t_, projMat1);
  cv::Mat projMat2(3, 4, CV_64F);
  cv::hconcat(_cam2.R_, _cam2.t_, projMat2);
  std::cout << projMat1 << std::endl;
  std::cout << projMat2 << std::endl;


  cv::Mat homo_space_pts(4, common_labels.size(), CV_64F);
  cv::triangulatePoints(projMat1, projMat2, 
                        rectified_pts1, rectified_pts2, homo_space_pts);

  std::cout << "homo_space_pts.size " << homo_space_pts.size() << std::endl;

  for (int i = 0; i < homo_space_pts.cols; ++i) {
    auto x = homo_space_pts.at<double>(0, i);
    auto y = homo_space_pts.at<double>(1, i);
    auto z = homo_space_pts.at<double>(2, i);
    auto u = homo_space_pts.at<double>(3, i);
    cv::Point3d current_pt(x/u, y/u, z/u);
    //std::cout << current_pt << std::endl;
    const auto label = common_labels[i];
    auto pt = current_pt;
    _space_pts.get_labeled_pt(label, pt);
    current_pt += pt;
    current_pt /= 2;
    _space_pts.insert(label, current_pt);
    _cam1.space_pt_labels_.insert(label);
    _cam2.space_pt_labels_.insert(label);
  }


  /*
  // with intrinsic matrix
  cv::Mat KprojMat1;// = _cam1.intrinsic_ * projMat1;
  cv::Mat KprojMat2;// = _cam2.intrinsic_ * projMat2;

  cv::Mat R1, R2, Q;
  cv::stereoRectify(_cam1.intrinsic_, _cam1.dist_coeff_, 
                    _cam2.intrinsic_, _cam2.dist_coeff_,
                    cv::Size(2592, 1944),
                    R, t, R1, R2, KprojMat1, KprojMat2, Q);
  
  std::vector<cv::Point2d> common_pts1;
  retrieve_points(_cam1, common_pt_idx, common_pts1);
  std::vector<cv::Point2d> common_pts2;
  retrieve_points(_cam2, common_pt_idx, common_pts2);
  cv::Mat k_homo_pts;
  cv::triangulatePoints(KprojMat1, KprojMat2,
                        common_pts1, common_pts2, k_homo_pts);
  std::cout << k_homo_pts.size() << std::endl;

  for (int i = 0; i < k_homo_pts.cols; ++i) {
    // auto x = homo_pt.at<float>(0, i);
    // auto y = homo_pt.at<float>(1, i);
    // auto z = homo_pt.at<float>(2, i);
    // auto u = homo_pt.at<float>(3, i);
    // space_pts.push_back(cv::Point3f(x/u, y/u, z/u));

    auto x = k_homo_pts.at<float>(0, i);
    auto y = k_homo_pts.at<float>(1, i);
    auto z = k_homo_pts.at<float>(2, i);
    auto u = k_homo_pts.at<float>(3, i);
    cv::Point3d current_pt(x/u, y/u, z/u);

    const auto label = common_pt_idx[i];
    cv::Point3d pt = current_pt;
    _space_pts.get_labeled_pt(label, pt);
    current_pt += pt;
    current_pt /= 2;
    _space_pts.insert(label, current_pt);
    _cam1.space_pt_labels_.insert(label);
    _cam2.space_pt_labels_.insert(label);
  }
  */
}



void construct_3d_pts(std::vector<Camera> &_cams,
                      SpacePoints<cv::Point3d> &_space_pts) {
  // for (std::size_t i = 0; i < _cams.size(); ++i) {
  //   for (std::size_t j = i; j < _cams.size()-1; ++j) {
  triangulate_pts(_cams[0], _cams[1], _space_pts);

  std::cout << "_space_pts " << _space_pts.size() << std::endl;
  // for (int i = 0; i < 5; ++i) {
  //   std::cout << _space_pts.points_[i] << std::endl;
  // }
  // std::cout << std::endl;
  //     std::cout << _space_pts.size() << std::endl;
  //   }
  // }
  // std::cout << _cams[1].R_ << std::endl;
  // std::cout << _cams[1].t_ << std::endl;
  /*
  _space_pts.clear();
  _cams[0].space_pt_labels_.clear();
  _cams[0].R_ = cv::Mat::eye(3, 3, CV_64F);
  _cams[0].t_ = cv::Mat::ones(3, 1, CV_64F);

  _cams[1].space_pt_labels_.clear();
  _cams[1].R_ = cv::Mat::eye(3, 3, CV_64F);
  _cams[1].t_ = cv::Mat::zeros(3, 1, CV_64F);
  
  triangulate_pts(_cams[1], _cams[0], _space_pts);
  std::cout << _cams[0].R_ << std::endl;
  std::cout << _cams[0].t_ << std::endl;
  */
  // std::vector<Camera> cam23 = {_cams[0], _cams[1]};//, _cams[2]};    
  // BundleAllCameras BA(&cam23, &_space_pts);
  // BA.Optimize();

  cv::viz::writeCloud("bsolved.ply", _space_pts.points_);

  /*

  const double c = std::sqrt(2)/2;
  double r[9] = {c, -c, 0, c, c, 0, 0, 0, 1};
  _cams[0].space_pt_labels_.clear();
  _cams[0].R_ = cv::Mat(3, 3, CV_64F, r); //cv::Mat::eye(3, 3, CV_64F);
  _cams[0].t_ = cv::Mat::ones(3, 1, CV_64F);

  _cams[1].space_pt_labels_.clear();
  _cams[1].R_ = cv::Mat::eye(3, 3, CV_64F);
  _cams[1].t_ = cv::Mat::zeros(3, 1, CV_64F);
  
  triangulate_pts(_cams[1], _cams[0], _space_pts);



  
  BA.Optimize();

  cv::viz::writeCloud("solved.ply", _space_pts.points_);
  */
}
                      
